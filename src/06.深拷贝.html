<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    const _completeDeepClone = (target, map = new Map()) => {
      // 补全代码
      // 当target为：null Date 正则 Dom元素 时，终止操作并返回
      if (target === null) return null
      if (target instanceof Date) return new Date(target)
      if (target instanceof RegExp) return new RegExp(target)
      if (target instanceof HTMLElement) return target

      if (typeof target !== 'object') return target // 当target为基本数据类型时

      if (map.get(target)) return map.get(target) // 拷贝对象前去weakMap中查看是否已存在
      const cloneTarget = new target.constructor() // new一个与target相同的数据类型
      map.set(target, cloneTarget) // 把当前target传入map

      Reflect.ownKeys(target).forEach((key) => {
        cloneTarget[key] = _completeDeepClone(target[key], map) // 递归拷贝
      })
      return cloneTarget
    }

    // 测试
    const obj = {
      a: true,
      b: 100,
      c: 'str',
      d: undefined,
      e: null,
      f: Symbol('f'),
      [Symbol('name')]: 'lin',
      g: {
        g1: {}, // 深层对象
      },
      h: [], // 数组
      i: new Date(), // Date
      j: /abc/, // 正则
      k: function () {}, // 函数
      l: [document.getElementById('foo')], // 引入Map 的意义，处理可能被清除的 DOM 元素
    }

    obj.obj = obj // 循环引用

    const newObj = _completeDeepClone(obj)
    console.log(newObj, obj)
  </script>
</html>
